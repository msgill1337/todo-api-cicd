trigger:
  branches:
    include:
      # - main
      - Dev

pool:
  vmImage: 'ubuntu-latest'

variables:
  - group: todo-api-variables  # You'll create this
  - name: buildNumber
    value: '$(Build.BuildNumber)'
  - name: acrName
    value: 'acrprod01mg1337'  # Replace with your ACR name
  - name: imageName
    value: 'todo-api'
  - name: dockerConnectionName
    value: 'acr-connection'
  - name: k8sServiceConnection
    value: 'aks-connection'

stages:
  # ========================================
  # STAGE 1: BUILD
  # ========================================
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildJob
        displayName: 'Build Docker Image'
        steps:
          # YOUR TASK: Checkout code
          - checkout: self

          # YOUR TASK: Build Docker image
          - task: Docker@2
            displayName: 'Build Docker Image'
            inputs:
                command: 'build'
                Dockerfile: 'Dockerfile'
                repository: '$(imageName)'
                tags: '$(Build.BuildId)'
              # Fill in the Docker task parameters
              # Hint: command, repository, dockerfile, tags

          # YOUR TASK: Run unit tests
          - script: |
              docker run -d --name test-container $(imageName):$(Build.BuildId)

              sleep 5
              # Run tests here
              # Hint: docker run with test command
              docker exec test-container npm test
              docker stop test-container
              docker rm test-container
            displayName: 'Run Unit Tests'
            continueOnError: false


          # YOUR TASK: Scan image with Trivy
          - script: |
              # Install and run Trivy
              # Scan for vulnerabilities

              sudo apt-get update
              sudo apt-get install wget apt-transport-https gnupg lsb-release -y
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y

              echo "Scanning image for vulnerabilities..."
              # Scan and save report
              trivy image --format table --output trivy-report.txt $(imageName):$(Build.BuildId)

              cat trivy-report.txt

              trivy image --exit-code 1 --severity CRITICAL $(imageName):$(Build.BuildId)
            displayName: 'Security Scan with Trivy'
            continueOnError: false

          - script: |
                docker tag $(imageName):$(Build.BuildId) $(ACR_LOGIN_SERVER)/$(imageName):$(Build.BuildId)
            displayName: 'Tagging the image before push'
          # YOUR TASK: Push image to ACR
          - task: Docker@2
            displayName: 'Push to ACR'
            inputs:
              command: 'push'
              containerRegistry: '$(dockerConnectionName)'
              repository: '$(imageName)'
              tags: '$(Build.BuildId)'
              # Fill in push parameters

  # # ========================================
  # # STAGE 2: DEPLOY TO DEV
  # # ========================================
  # - stage: DeployDev
  #   displayName: 'Deploy to Dev'
  #   dependsOn: Build
  #   condition: succeeded()
  #   jobs:
  #     - deployment: DeployDevJob
  #       displayName: 'Deploy to Dev Environment'
  #       environment: 'dev'
  #       strategy:
  #         runOnce:
  #           deploy:
  #             steps:
  #               # YOUR TASK: Replace tokens in K8s manifests
  #               - checkout: self
  #               - script: |
  #                   ls -la

  #                   sed -i 's|#{ACR_NAME}#\.azurecr\.io/todo-api:#{BUILD_NUMBER}#|$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId)|g' k8s/deployment.yaml
  #                   sed -i 's|#{ENVIRONMENT}#|dev|g' k8s/deployment.yaml
  #                   sed -i 's|#{BUILD_NUMBER}#|$(Build.BuildId)|g' k8s/deployment.yaml
  #                 displayName: 'Replace tokens in manifests'
                

  #               # YOUR TASK: Deploy to AKS dev namespace
  #               - task: Kubernetes@1
  #                 displayName: 'Deploy to AKS Dev'
  #                 inputs:
  #                   # Configure kubectl deployment
  #                   connectionType: 'Kubernetes Service Connection'
  #                   kubernetesServiceEndpoint: '$(k8sServiceConnection)'
  #                   namespace: 'todo-dev'
  #                   command: 'apply'
  #                   arguments: '-f k8s/deployment.yaml'

  #               - task: Kubernetes@1
  #                 displayName: 'Setup kubectl context'
  #                 inputs:
  #                   connectionType: 'Kubernetes Service Connection'
  #                   kubernetesServiceEndpoint: '$(k8sServiceConnection)'
  #                   namespace: 'dev'
  #                   command: 'login'

  #               # YOUR TASK: Run smoke tests
  #               - script: |
  #                   echo "Running smoke tests against deployed app in dev namespace..."
                    
  #                   # Wait for deployment to be ready
  #                   kubectl wait --for=condition=available --timeout=120s deployment/todo-api -n todo-dev
                    
  #                   # Get the service external IP (LoadBalancer)
  #                   SERVICE_IP=$(kubectl get svc todo-api -n todo-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  #                   echo "Service IP: $SERVICE_IP"
                    
  #                   # Wait for LoadBalancer IP to be assigned
  #                   RETRY_COUNT=0
  #                   MAX_RETRIES=30
  #                   while [ -z "$SERVICE_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
  #                     echo "Waiting for LoadBalancer IP... (attempt $RETRY_COUNT/$MAX_RETRIES)"
  #                     sleep 10
  #                     SERVICE_IP=$(kubectl get svc todo-api -n todo-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  #                     RETRY_COUNT=$((RETRY_COUNT + 1))
  #                   done
                    
  #                   if [ -z "$SERVICE_IP" ]; then
  #                     echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
  #                     exit 1
  #                   fi
                    
  #                   echo "Testing health endpoint at http://$SERVICE_IP/health"
                    
  #                   # Test health endpoint
  #                   HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)
                    
  #                   if [ "$HEALTH_RESPONSE" = "200" ]; then
  #                     echo "‚úÖ Health check passed!"
  #                     curl -s http://$SERVICE_IP/health | jq '.'
  #                   else
  #                     echo "‚ùå Health check failed with status: $HEALTH_RESPONSE"
  #                     exit 1
  #                   fi
                    
  #                   # Test API endpoint
  #                   echo "Testing API endpoint at http://$SERVICE_IP/api/todos"
  #                   API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/api/todos)
                    
  #                   if [ "$API_RESPONSE" = "200" ]; then
  #                     echo "‚úÖ API check passed!"
  #                     curl -s http://$SERVICE_IP/api/todos | jq '.'
  #                   else
  #                     echo "‚ùå API check failed with status: $API_RESPONSE"
  #                     exit 1
  #                   fi
                    
  #                   echo "‚úÖ All smoke tests passed!"
  #                 displayName: 'Smoke Tests'
  #                 continueOnError: false

  # # ========================================
  # # STAGE 3: DEPLOY TO STAGING
  # # ========================================
  # - stage: DeployStaging
  #   displayName: 'Deploy to Staging'
  #   dependsOn: DeployDev
  #   condition: succeeded()
  #   jobs:
  #     - deployment: DeployStagingJob
  #       displayName: 'Deploy to Staging Environment'
  #       environment: 'staging'  # Manual approval configured here
  #       strategy:
  #         runOnce:
  #           deploy:
  #             steps:
  #               # YOUR TASK: Similar to dev, but staging namespace
  #               - checkout: self
  #               - script: |
  #                   sed -i 's|#{ACR_NAME}#\.azurecr\.io/todo-api:#{BUILD_NUMBER}#|$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId)|g' k8s/deployment.yaml
  #                   sed -i 's|#{ENVIRONMENT}#|staging|g' k8s/deployment.yaml
  #                   sed -i 's|#{BUILD_NUMBER}#|$(Build.BuildId)|g' k8s/deployment.yaml
  #                 displayName: 'Replace tokens in manifests'
                

  #               # YOUR TASK: Deploy to AKS Staging namespace
  #               - task: Kubernetes@1
  #                 displayName: 'Deploy to AKS Staging'
  #                 inputs:
  #                   # Configure kubectl deployment
  #                   connectionType: 'Kubernetes Service Connection'
  #                   kubernetesServiceEndpoint: '$(k8sServiceConnection)'
  #                   namespace: 'todo-staging'
  #                   command: 'apply'
  #                   arguments: '-f k8s/deployment.yaml'

  #               - task: Kubernetes@1
  #                 displayName: 'Setup kubectl context'
  #                 inputs:
  #                   connectionType: 'Kubernetes Service Connection'
  #                   kubernetesServiceEndpoint: '$(k8sServiceConnection)'
  #                   namespace: 'dev'
  #                   command: 'login'
      

  #               # YOUR TASK: Run smoke tests
  #               - script: |
  #                   echo "Running smoke tests against deployed app in staging namespace..."
                    
  #                   # Wait for deployment to be ready
  #                   kubectl wait --for=condition=available --timeout=120s deployment/todo-api -n todo-staging
                    
  #                   # Get the service external IP (LoadBalancer)
  #                   SERVICE_IP=$(kubectl get svc todo-api -n todo-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  #                   echo "Service IP: $SERVICE_IP"
                    
  #                   # Wait for LoadBalancer IP to be assigned
  #                   RETRY_COUNT=0
  #                   MAX_RETRIES=30
  #                   while [ -z "$SERVICE_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
  #                     echo "Waiting for LoadBalancer IP... (attempt $RETRY_COUNT/$MAX_RETRIES)"
  #                     sleep 10
  #                     SERVICE_IP=$(kubectl get svc todo-api -n todo-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  #                     RETRY_COUNT=$((RETRY_COUNT + 1))
  #                   done
                    
  #                   if [ -z "$SERVICE_IP" ]; then
  #                     echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
  #                     exit 1
  #                   fi
                    
  #                   echo "Testing health endpoint at http://$SERVICE_IP/health"
                    
  #                   # Test health endpoint
  #                   HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)
                    
  #                   if [ "$HEALTH_RESPONSE" = "200" ]; then
  #                     echo "‚úÖ Health check passed!"
  #                     curl -s http://$SERVICE_IP/health | jq '.'
  #                   else
  #                     echo "‚ùå Health check failed with status: $HEALTH_RESPONSE"
  #                     exit 1
  #                   fi
                    
  #                   # Test API endpoint
  #                   echo "Testing API endpoint at http://$SERVICE_IP/api/todos"
  #                   API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/api/todos)
                    
  #                   if [ "$API_RESPONSE" = "200" ]; then
  #                     echo "‚úÖ API check passed!"
  #                     curl -s http://$SERVICE_IP/api/todos | jq '.'
  #                   else
  #                     echo "‚ùå API check failed with status: $API_RESPONSE"
  #                     exit 1
  #                   fi
                    
  #                   echo "‚úÖ All smoke tests passed!"
  #                 displayName: 'Smoke Tests'
  #                 env: 
  #                   KUBECONFIG: $(System.DefaultWorkingDirectory)/kubeconfig
  #                 continueOnError: false

  # ========================================
  # STAGE 4: DEPLOY TO PROD
  # ========================================
  - stage: DeployProd
    displayName: 'Deploy to Production'
    # dependsOn: DeployStaging
    # condition: succeeded()
    jobs:
      - deployment: DeployProdJob
        displayName: 'Deploy to Production Environment'
        environment: 'production'  # Manual approval required
        strategy:
          runOnce:
            deploy:
              steps:
                # YOUR TASK: Production deployment
                # Consider blue-green deployment here
                - script: echo "Deploy to production"
                - checkout: self
                
                - script: |
                    sed -i 's|#{ACR_NAME}#\.azurecr\.io/todo-api:#{BUILD_NUMBER}#|$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId)|g' k8s/prod-deployment.yaml
                    sed -i 's|#{ENVIRONMENT}#|production|g' k8s/prod-deployment.yaml
                    sed -i 's|#{BUILD_NUMBER}#|$(Build.BuildId)|g' k8s/prod-deployment.yaml
                  displayName: 'Replace tokens in manifests'
                
                # YOUR TASK: Deploy to AKS Production namespace
                - task: Kubernetes@1
                  displayName: 'Deploy to AKS Production'
                  inputs:
                    # Configure kubectl deployment
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'todo-prod'
                    command: 'apply'
                    arguments: '-f k8s/prod-deployment.yaml'

                - task: Kubernetes@1
                  displayName: 'Setup kubectl context'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'dev'
                    command: 'login'
      
                # Step 2: Wait for deployment to be ready
                - task: Kubernetes@1
                  displayName: 'Wait for deployment'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'todo-prod'
                    command: 'wait'
                    arguments: '--for=condition=available --timeout=300s deployment/todo-api-new'


                - script: |
                    echo "Testing blue/green deployment before switching traffic..."
                    
                    # Get the active slot 
                    SLOT=$(kubectl get svc todo-api-service -n todo-prod -o jsonpath='{.spec.selector.version}')
                    echo "Active slot: $SLOT"
                    
                    # Determine the OTHER slot
                    if [ "$SLOT" = "blue" ]; then
                      OTHER_SLOT="green"
                    else
                      OTHER_SLOT="blue"
                    fi
                    
                    echo "üöÄ Deploying to $OTHER_SLOT..."

                    kubectl set image deployment/todo-api-$OTHER_SLOT -n todo-prod \
                      todo-api=$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId) --record

                    echo "üìà Scaling up $OTHER_SLOT"

                    kubectl scale deployment/todo-api-$OTHER_SLOT -n todo-prod --replicas=2

                    echo "‚è≥ Waiting for rollout..."

                    kubectl rollout status deployment/todo-api-$OTHER_SLOT -n todo-prod --timeout=5m

                    echo "üß™ Running smoke tests..."

                    POD=$(kubectl get pods -n todo-prod -l app=todo-api,version=$OTHER_SLOT -o jsonpath='{.items[0].metadata.name}')

                    kubectl port-forward -n todo-prod $POD 8080:3000 &
                    PF_PID=$!
                    sleep 20

                    curl -f http://localhost:8080/health || { kill $PF_PID; exit 1; }
                    kill $PF_PID

                    echo "üîÑ Switching traffic to $OTHER_SLOT..."
                    kubectl patch service todo-api-service -n todo-prod \
                      -p "{\"spec\":{\"selector\":{\"version\":\"$OTHER_SLOT\"}}}"

                    echo "‚úÖ Deployment complete! Traffic now on $OTHER_SLOT"
                    
                    echo "‚ÑπÔ∏è  Old version ($SLOT) being scaled down"

                    kubectl scale deployment/todo-api-$SLOT -n todo-prod --replicas=0


                    # # CRITICAL: Wait for the inactive deployment to be ready
                    # echo "Waiting for $OTHER_SLOT deployment to be ready..."
                    # kubectl wait --for=condition=available --timeout=300s deployment/todo-api-new -n todo-prod || {
                    #   echo "‚ùå $OTHER_SLOT deployment is not ready!"
                    #   exit 1
                    # }
                    
                    # # Check if pods are running
                    # kubectl get pods -n todo-prod -l app=todo-api,version=${SLOT}
                    
                    # echo "Testing $OTHER_SLOT slot before switching..." 

                    # # Port forward to the inactive slot
                    # echo "Starting port-forward to $OTHER_SLOT..."
                    # kubectl port-forward -n todo-prod svc/todo-api-${OTHER_SLOT}-service 8080:80 &
                    # PF_PID=$!

                    # sleep 20
                    
                    # if ! ps -p $PF_PID > /dev/null; then
                    #   echo "‚ùå Port-forward failed to start!"
                    #   exit 1
                    # fi

                    # echo "Port-forward established (PID: $PF_PID)"


                    # # Test health endpoint
                    # HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
                    
                    # if [ "$HEALTH" != "200" ]; then
                    #   echo "‚ùå $OTHER_SLOT slot health check FAILED (status: $HEALTH)"
                    #   echo "‚ùå NOT switching traffic. $OTHER_SLOT deployment has issues!"
                    #   kill $PF_PID
                    #   exit 1
                    # fi
                    
                    # echo "‚úÖ $OTHER_SLOT slot is healthy (status: 200)"
                    
                    # # Additional API test
                    # API=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/todos)
                    # if [ "$API" != "200" ]; then
                    #   echo "‚ùå $OTHER_SLOT slot API check FAILED (status: $API)"
                    #   kill $PF_PID
                    #   exit 1
                    # fi
                    
                    # echo "‚úÖ $OTHER_SLOT slot passed all tests"
                    # kill $PF_PID
                    
                    # # Save slot info for next steps
                    # echo "##vso[task.setvariable variable=activeSlot]$SLOT"
                    # echo "##vso[task.setvariable variable=inactiveSlot]$OTHER_SLOT"
                  displayName: 'Check and switch'
                  continueOnError: false

                # - script: |
                #     echo "$(inactiveSlot) is healthy. Switching traffic from $(activeSlot) to $(inactiveSlot)..."
                #     kubectl patch svc todo-api-service -n todo-prod -p "{\"spec\":{\"selector\":{\"version\":\"$(inactiveSlot)\"}}}"
                #     echo "‚úÖ Traffic switched to $(inactiveSlot)!"
                #   displayName: 'Switch Traffic to healthy slot'

                # - script: |
                #     echo "Monitoring $(inactiveSlot) with production traffic..."
                #     SERVICE_IP=$(kubectl get svc todo-api-service -n todo-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                    
                #     # Monitor for 5 minutes
                #     FAILURES=0
                #     MAX_FAILURES=3
                    
                #     for i in {1..30}; do
                #       sleep 10
                      
                #       HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)
                      
                #       if [ "$HEALTH" != "200" ]; then
                #         FAILURES=$((FAILURES + 1))
                #         echo "‚ö†Ô∏è Health check failed ($FAILURES/$MAX_FAILURES) - Status: $HEALTH"
                        
                #         if [ $FAILURES -ge $MAX_FAILURES ]; then
                #           echo "‚ùå Too many failures! ROLLING BACK to $(activeSlot)..."
                #           kubectl patch svc todo-api-service -n todo-prod -p "{\"spec\":{\"selector\":{\"version\":\"$(activeSlot)\"}}}"
                #           echo "‚úÖ Rolled back to $(activeSlot) slot"
                #           exit 1
                #         fi
                #       else
                #         echo "‚úÖ Health check $i/30 passed"
                #         FAILURES=0
                #       fi
                #     done
                    
                #     echo "‚úÖ $(inactiveSlot) slot is stable with production traffic!"
                #   displayName: 'Post-switch monitoring (Auto-rollback)'
                #   continueOnError: false