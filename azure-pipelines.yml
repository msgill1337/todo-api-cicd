trigger:
  branches:
    include:
      # - main
      - Dev

pool:
  vmImage: 'ubuntu-latest'

variables:
  - group: todo-api-variables  # You'll create this
  - name: buildNumber
    value: '$(Build.BuildNumber)'
  - name: acrName
    value: 'acrprod01mg1337'  # Replace with your ACR name
  - name: imageName
    value: 'todo-api'
  - name: dockerConnectionName
    value: 'acr-connection'
  - name: k8sServiceConnection
    value: 'aks-connection'

stages:
  # ========================================
  # STAGE 1: BUILD
  # ========================================
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildJob
        displayName: 'Build Docker Image'
        steps:
          # YOUR TASK: Checkout code
          - checkout: self

          # YOUR TASK: Build Docker image
          - task: Docker@2
            displayName: 'Build Docker Image'
            inputs:
                command: 'build'
                Dockerfile: 'Dockerfile'
                repository: '$(imageName)'
                tags: '$(Build.BuildId)'
              # Fill in the Docker task parameters
              # Hint: command, repository, dockerfile, tags

          # YOUR TASK: Run unit tests
          - script: |
              docker run -d --name test-container $(imageName):$(Build.BuildId)

              sleep 5
              # Run tests here
              # Hint: docker run with test command
              docker exec test-container npm test
              docker stop test-container
              docker rm test-container
            displayName: 'Run Unit Tests'
            continueOnError: false


          # YOUR TASK: Scan image with Trivy
          - script: |
              # Install and run Trivy
              # Scan for vulnerabilities

              sudo apt-get update
              sudo apt-get install wget apt-transport-https gnupg lsb-release -y
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y

              echo "Scanning image for vulnerabilities..."
              # Scan and save report
              trivy image --format table --output trivy-report.txt $(imageName):$(Build.BuildId)

              cat trivy-report.txt

              trivy image --exit-code 1 --severity CRITICAL $(imageName):$(Build.BuildId)
            displayName: 'Security Scan with Trivy'
            continueOnError: false

          - script: |
                docker tag $(imageName):$(Build.BuildId) $(ACR_LOGIN_SERVER)/$(imageName):$(Build.BuildId)
            displayName: 'Tagging the image before push'
          # YOUR TASK: Push image to ACR
          - task: Docker@2
            displayName: 'Push to ACR'
            inputs:
              command: 'push'
              containerRegistry: '$(dockerConnectionName)'
              repository: '$(imageName)'
              tags: '$(Build.BuildId)'
              # Fill in push parameters

  # ========================================
  # STAGE 2: DEPLOY TO DEV
  # ========================================
  - stage: DeployDev
    displayName: 'Deploy to Dev'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployDevJob
        displayName: 'Deploy to Dev Environment'
        environment: 'dev'
        strategy:
          runOnce:
            deploy:
              steps:
                # YOUR TASK: Replace tokens in K8s manifests
                - checkout: self
                - script: |
                    ls -la

                    sed -i 's|#{ACR_NAME}#\.azurecr\.io/todo-api:#{BUILD_NUMBER}#|$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId)|g' k8s/deployment.yaml
                    sed -i 's|#{ENVIRONMENT}#|dev|g' k8s/deployment.yaml
                    sed -i 's|#{BUILD_NUMBER}#|$(Build.BuildId)|g' k8s/deployment.yaml
                  displayName: 'Replace tokens in manifests'
                

                # YOUR TASK: Deploy to AKS dev namespace
                - task: Kubernetes@1
                  displayName: 'Deploy to AKS Dev'
                  inputs:
                    # Configure kubectl deployment
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'todo-dev'
                    command: 'apply'
                    arguments: '-f k8s/deployment.yaml'

                - task: Kubernetes@1
                  displayName: 'Setup kubectl context'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'dev'
                    command: 'login'

                # YOUR TASK: Run smoke tests
                - script: |
                    echo "Running smoke tests against deployed app in dev namespace..."
                    
                    # Wait for deployment to be ready
                    kubectl wait --for=condition=available --timeout=120s deployment/todo-api -n todo-dev
                    
                    # Get the service external IP (LoadBalancer)
                    SERVICE_IP=$(kubectl get svc todo-api -n todo-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                    echo "Service IP: $SERVICE_IP"
                    
                    # Wait for LoadBalancer IP to be assigned
                    RETRY_COUNT=0
                    MAX_RETRIES=30
                    while [ -z "$SERVICE_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                      echo "Waiting for LoadBalancer IP... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                      sleep 10
                      SERVICE_IP=$(kubectl get svc todo-api -n todo-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                    done
                    
                    if [ -z "$SERVICE_IP" ]; then
                      echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
                      exit 1
                    fi
                    
                    echo "Testing health endpoint at http://$SERVICE_IP/health"
                    
                    # Test health endpoint
                    HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)
                    
                    if [ "$HEALTH_RESPONSE" = "200" ]; then
                      echo "✅ Health check passed!"
                      curl -s http://$SERVICE_IP/health | jq '.'
                    else
                      echo "❌ Health check failed with status: $HEALTH_RESPONSE"
                      exit 1
                    fi
                    
                    # Test API endpoint
                    echo "Testing API endpoint at http://$SERVICE_IP/api/todos"
                    API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/api/todos)
                    
                    if [ "$API_RESPONSE" = "200" ]; then
                      echo "✅ API check passed!"
                      curl -s http://$SERVICE_IP/api/todos | jq '.'
                    else
                      echo "❌ API check failed with status: $API_RESPONSE"
                      exit 1
                    fi
                    
                    echo "✅ All smoke tests passed!"
                  displayName: 'Smoke Tests'
                  continueOnError: false

  # ========================================
  # STAGE 3: DEPLOY TO STAGING
  # ========================================
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: DeployDev
    condition: succeeded()
    jobs:
      - deployment: DeployStagingJob
        displayName: 'Deploy to Staging Environment'
        environment: 'staging'  # Manual approval configured here
        strategy:
          runOnce:
            deploy:
              steps:
                # YOUR TASK: Similar to dev, but staging namespace
                - checkout: self
                - script: |
                    sed -i 's|#{ACR_NAME}#\.azurecr\.io/todo-api:#{BUILD_NUMBER}#|$(ACR_LOGIN_SERVER)/todo-api:$(Build.BuildId)|g' k8s/deployment.yaml
                    sed -i 's|#{ENVIRONMENT}#|staging|g' k8s/deployment.yaml
                    sed -i 's|#{BUILD_NUMBER}#|$(Build.BuildId)|g' k8s/deployment.yaml
                  displayName: 'Replace tokens in manifests'
                

                # YOUR TASK: Deploy to AKS Staging namespace
                - task: Kubernetes@1
                  displayName: 'Deploy to AKS Staging'
                  inputs:
                    # Configure kubectl deployment
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'todo-staging'
                    command: 'apply'
                    arguments: '-f k8s/deployment.yaml'

                - task: Kubernetes@1
                  displayName: 'Setup kubectl context'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'dev'
                    command: 'login'
      

                # YOUR TASK: Run smoke tests
                - script: |
                    echo "Running smoke tests against deployed app in staging namespace..."
                    
                    # Wait for deployment to be ready
                    kubectl wait --for=condition=available --timeout=120s deployment/todo-api -n todo-staging
                    
                    # Get the service external IP (LoadBalancer)
                    SERVICE_IP=$(kubectl get svc todo-api -n todo-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                    echo "Service IP: $SERVICE_IP"
                    
                    # Wait for LoadBalancer IP to be assigned
                    RETRY_COUNT=0
                    MAX_RETRIES=30
                    while [ -z "$SERVICE_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                      echo "Waiting for LoadBalancer IP... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                      sleep 10
                      SERVICE_IP=$(kubectl get svc todo-api -n todo-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                    done
                    
                    if [ -z "$SERVICE_IP" ]; then
                      echo "Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
                      exit 1
                    fi
                    
                    echo "Testing health endpoint at http://$SERVICE_IP/health"
                    
                    # Test health endpoint
                    HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)
                    
                    if [ "$HEALTH_RESPONSE" = "200" ]; then
                      echo "✅ Health check passed!"
                      curl -s http://$SERVICE_IP/health | jq '.'
                    else
                      echo "❌ Health check failed with status: $HEALTH_RESPONSE"
                      exit 1
                    fi
                    
                    # Test API endpoint
                    echo "Testing API endpoint at http://$SERVICE_IP/api/todos"
                    API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/api/todos)
                    
                    if [ "$API_RESPONSE" = "200" ]; then
                      echo "✅ API check passed!"
                      curl -s http://$SERVICE_IP/api/todos | jq '.'
                    else
                      echo "❌ API check failed with status: $API_RESPONSE"
                      exit 1
                    fi
                    
                    echo "✅ All smoke tests passed!"
                  displayName: 'Smoke Tests'
                  env: 
                    KUBECONFIG: $(System.DefaultWorkingDirectory)/kubeconfig
                  continueOnError: false

  # ========================================
  # STAGE 4: DEPLOY TO PROD
  # ========================================
  - stage: DeployProd
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: succeeded()
    jobs:
      - deployment: DeployProdJob
        displayName: 'Deploy to Production Environment'
        environment: 'production'  # Manual approval required
        strategy:
          runOnce:
            deploy:
              steps:
                # YOUR TASK: Production deployment
                # Consider blue-green deployment here
                - script: echo "Deploy to production"
                - checkout: self
                # YOUR TASK: Deploy to AKS Production namespace
                - task: Kubernetes@1
                  displayName: 'Deploy to AKS Production'
                  inputs:
                    # Configure kubectl deployment
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'todo-prod'
                    command: 'apply'
                    arguments: '-f k8s/prod-deployment.yaml'

                - task: Kubernetes@1
                  displayName: 'Setup kubectl context'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'dev'
                    command: 'login'
      
                # Step 2: Wait for deployment to be ready
                - task: Kubernetes@1
                  displayName: 'Wait for deployment'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: '$(k8sServiceConnection)'
                    namespace: 'prod'
                    command: 'wait'
                    arguments: '--for=condition=available --timeout=300s deployment/todo-api-new'


                # YOUR TASK: Run smoke tests
                - script: |
                    echo "Testing blue/green deployment before switching traffic..."
                    

                    #Get the active slot 
                    SLOT=$(kubectl get svc todo-api-service -n todo-prod -o jsonpath='{.spec.selector.version}')
                    echo "SLOT $SLOT is active "
                    
                    if [ $SLOT -eq "blue" ] then
                      $OTHER_SLOT = "green"
                      kubectl port-forward -n todo-prod svc/todo-api-green-service 8080:80
                      PF_PID=$!
                      sleep 5
                    else
                      $OTHER_SLOT = "blue"
                      kubectl port-forward -n todo-prod svc/todo-api-blue-service 8080:80
                      PF_PID=$!
                      sleep 5
                    fi

                    HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health

                    if [ "$HEALTH" != "200" ]; then
                      echo "❌ Green slot health check FAILED (status: $HEALTH)"
                      echo "❌ NOT switching traffic. Green deployment has issues!"
                      kill $PF_PID
                      exit 1  # STOP HERE - don't switch traffic
                    fi
                    
                    echo "✅ Green slot is healthy (status: 200)"
                    
                    # Additional API test
                    API=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/todos)
                    if [ "$API" != "200" ]; then
                      echo "❌ Green slot API check FAILED (status: $API)"
                      kill $PF_PID
                      exit 1
                    fi

                    echo "✅ Green slot passed all tests"
                    kill $PF_PID

            
                  displayName: 'Pre-Switch Health Check'
                  continueOnError: false

                - script: |
                    echo "$OTHER_SLOT is healthy. Switching traffic from $SLOT to $OTHER_SLOT...."
                    kubectl patch svc todo-api-service -n todo-prod -p '{"spec":{"selector":{"version":"$OTHER_SLOT"}}}'
                    echo "✅ Traffic switched to $OTHER_SLOT!"
                  displayName: 'Switch Traffic to healthy slot'

                - script: |
                    echo "Monitoring $OTHER_SLOT with production traffic...."
                    SERVICE_IP=$(kubectl get svc todo-api-service -n todo-prod -o jsonpath='{.status.loadbalancer.ingress[0].ip}')

                    #Monitor for 5 minutes
                    FAILURES=0
                    MAX_FAILURES=3

                    for i in {1..30}; do
                      sleep 10

                      HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVICE_IP/health)

                      if [ "$HEALTH" != "200" ]; then
                        FAILURES=$((FAILURES + 1))
                        echo "⚠️ Health check failed ($FAILURES/$MAX_FAILURES) - Status: $HEALTH"
                        
                        if [ $FAILURES -ge $MAX_FAILURES ]; then
                          echo "❌ Too many failures! ROLLING BACK to blue..."
                          kubectl patch svc todo-api-service -n prod -p '{"spec":{"selector":{"version":"$SLOT"}}}'
                          echo "✅ Rolled back to blue slot"
                          exit 1
                        fi
                      else
                        echo "✅ Health check $i/30 passed"
                        FAILURES=0  # Reset counter on success
                      fi
                    done

                    echo "✅ $OTHER_SLOT slot is stable with production traffic!"
                  displayName: Post-switch monitoring (Auto-rollback)
                  continueOnError: false

